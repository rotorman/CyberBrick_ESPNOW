# Firmware to flash internal and external ExpressLRS modules

The firmware can be built and flashed into the ExpressLRS hardware via EdgeTX passthrough (triggered in the background while uploading firmware either from [ExpressLRS Configurator](https://github.com/ExpressLRS/ExpressLRS-Configurator/releases/latest) or from VSCode and PlatformIO by [Python script](https://github.com/rotorman/CyberBrick_ESPNOW/transmitterFW/python/EdgeTXpassthrough.py)). External modules can be flashed via UART. Some (external) modules come with an integrated USB-to-serial adapter, others might need an external adapter, like [FTDI](https://www.sparkfun.com/ftdi-cable-5v-vcc-3-3v-i-o.html) or [Silabs CP2102](https://betafpv.com/collections/expresslrs-series-accessories/products/expresslrs-recovery-dongle), to flash them. You can use [Visual Studio Code](https://code.visualstudio.com/) and [PlatformIO](https://platformio.org/) to customize the code. The firmware code is using [Arduino framework](https://docs.platformio.org/en/latest/frameworks/arduino.html) for [Espressif ESP32](https://docs.platformio.org/en/latest/platforms/espressif32.html#platform-espressif32) platform, similar to the development of the [ExpressLRS firmware](https://www.expresslrs.org/software/toolchain-install/).

In case you wish to customize the code, as a first step you should try to build std. ExpressLRS firmware with Visual Studio Code and PlatformIO. As only if the latter succeeds, it does make sense to continue to load the PlatformIO project from this repository. Be also aware that by opening a new PlatformIO project for the first time, depending on your local configuration, a significant amount of time can pass, before all the necessary frameworks and libraries are downloaded. Keep an eye for progress bars in VSCode and always wait until previous operations are completed, before continuing. Even on a potent new computer and fast Internet connectivity, this can still take many many minutes, as sometimes multiple gigabytes of data need to be downloaded and unpacked.

<img src="https://www.expresslrs.org/assets/external/raw.githubusercontent.com/ExpressLRS/ExpressLRS-hardware/master/img/hardware.png" height="65px"> <img src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/esp-now-logo.png" height="65px"> <img src="https://avatars.githubusercontent.com/u/64278475" height="65px"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Visual_Studio_Code_1.35_icon.svg/250px-Visual_Studio_Code_1.35_icon.svg.png" height="65px"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/PlatformIO_logo.svg/500px-PlatformIO_logo.svg.png" height="65px"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Arduino_Logo.svg/330px-Arduino_Logo.svg.png" height="65px"> <img src="https://raw.githubusercontent.com/EdgeTX/edgetx/refs/heads/main/companion/src/images/icon.png" height="65px">

The code should work with any (internal or external) [ExpressLRS transmitter module](https://www.expresslrs.org/hardware/hardware-selection/#transmitter-selection) with an ESP32 or ESP32-S3 microcontroller paired with an arbitrary [EdgeTX](https://edgetx.org/) handset able to talk with ExpressLRS module(s). To use the latest code, that uses internally 32 channel transmission, you should flash EdgeTX firmware from the [EdgeTX pull request #6504](https://github.com/EdgeTX/edgetx/pull/6504).

After flashing, be sure to set your receiver ID to a non zero number (values 1 to 63 are accepted) and you should be able to control your CyberBrick from your EdgeTX handset, assuming the CyberBrick Core is running the [MicroPython ESPNOW reception code](https://github.com/rotorman/CyberBrick_ESPNOW/tree/main/receiverPY) from this repository. The default communication uses ESP-NOW broadcast addressing to send packets from handset to the CyberBrick model. Not only is this less reliable than explicitly binding to a specific model, it also does not allow more than one system pair to operate simultanously in the vicinity of each other, at least not without causing some serious interference to each other. In order to bind the transmitter to a specific ExpressLRS receiver, you can use the [Lua script](https://github.com/rotorman/CyberBrick_ESPNOW/tree/main/transmitterLua/). Open the Lua and select the `Bind` function in it and press within the 5 second window, as the bind process runs on the handset, the USER KEY button on the CyberBrick Core at least for 1 second. The Lua script should now list the MAC address of the CyberBrick Core instead of `Broadcast` and give you an additional menu point to Clear the binding as well. Please be aware that a binding is done for each EdgeTX model receiver number separately, which means you can easily this way bind multiple models to an EdgeTX handset, each model having it's own configuration and bind settings.

Large parts of the code used in this repository stem from the wonderful [ExpressLRS project](https://github.com/ExpressLRS/ExpressLRS/).

I have tested the code with RadioMaster TX16s mkII with internal ExpressLRS module, RadioMaster MT12 with internal 2.4 GHz ExpressLRS module, Jumper T15 with internal 2.4 GHz ExpressLRS module, external HappyModel ES24TX Pro module, external RadioMaster Ranger module and also with an ESP32 development kit (ESP32DevKitCv4).
